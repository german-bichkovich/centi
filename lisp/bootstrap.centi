# -*- mode: lisp -*-
# Bootstrap sequence for centi.
# All of required builtins are marked as such in builtins.lisp.

# (:define symbol value)
# A simplified version of define used for bootstrapping.
(environment:set! ((special () env env))
                  ((special (x) nil x) :define)
                  (special (symbol value) env
                    (environment:set! env
                                      symbol
                                      (evaluate value env))))

# NOTE defined here because it's part of the repl and
#      not doing so will break it.
(:define print :print)

(:define quote
  (special (form) nil form))

# Default truth value.
(:define true 'true)

# The only false value.
(:define false 'false)

# Lack of value.
(:define nil 'nil)

# Empty list symbol.
(:define () '())

(:define pair:head
  (wrap (special ((head . nil)) nil head)))

# (apply pair '(1 2)) <=> (pair '1 '2)
(:define apply
  (wrap (special (f args) env
          (evaluate (pair (unwrap f) args)
                    env))))

# (list:prepend 'x) <=> 'x
# (list:prepend 'x 'y) <=> (pair 'x 'y)
# (list:prepend 'x 'y 'z) <=> (pair 'x (pair 'y 'z))
# Create a new list with elements before last prepended
# to the last one.
(:define list:prepend
  (wrap (special (object . objects) env
          (if (pair? objects)
              (pair object (apply list:prepend objects))
              object))))

# (list . args)
# (list 'a (+ 1 2)) => (a 3)
(:define list
  (wrap (special args nil args)))

# (function (x) x) <=> (wrap (special (x) nil x))
(:define function
  (special (ptree . body) env
    (evaluate (list wrap
                    (list:prepend special ptree nil body))
              env)))

# (pair:tail pair)
# (pair:tail '(a . b)) => b
(:define pair:tail
  (function ((nil . tail)) tail))

# (list:fold + 0 '(1 2 3)) <=> (+ (+ (+ 1 0) 2) 3)
(:define list:fold
  (function (f value list)
    (if (pair? list)
        (list:fold f
                   (f value (pair:head list))
                   (pair:tail list))
        value)))

# Evaluate list of forms in provided environment,
# returning last result.
(:define evaluate-many
  (function (forms environment)
    (list:fold (function (nil f) (evaluate f environment))
               nil
               forms)))

# (ifs (x 1 2) (true 0)) <=> (if x (do 1 2) (if true (do 0) nil))
# If form with multiple tests.
(:define ifs
  (special ((test . body) . clauses) env
    (if (evaluate test env)
        (evaluate-many body env)
        (if (pair? clauses)
            (evaluate (pair ifs clauses) env)
            nil))))

(:define do
  (special forms env
    (evaluate-many forms env)))

# TODO die is not defined
# Destructure FORM over PTREE. Whenever ptree is a symbol, do
# (callback symbol form).
(:define destructure
  (function (ptree value callback)
    (ifs ((symbol? ptree)
          (ifs ((== ptree nil)
                nil)
               ((== ptree ())
                (if (== value ())
                    nil
                    (die "destructure: too many arguments")))
               (true
                (callback ptree value)
                nil)))
         ((pair? ptree)
          (if (pair? value)
              (do (destructure (pair:head ptree)
                               (pair:head value)
                               callback)
                  (destructure (pair:tail ptree)
                               (pair:tail value)
                               callback))
              (die "destructure: value is not a pair")))
         (true
          (die "destructure: bad ptree")))))

# Destructure value over the ptree and set each of
# the symbols to corresponding values in current environment.
(:define define
  (special (ptree value) env
    (:define value (evaluate value env))
    (destructure ptree value (function (k v)
                               (environment:set! env k v)))
    value))

# (let ((a 1) (b (+ a 2))) b) <=>
#   ((function (a) ((function (b) b) (+ a 2))) 1)
(define let
  (special (bindings . body) env
    (evaluate-many
     body
     (list:fold (function (env (ptree form))
                  (destructure ptree
                               (evaluate form env)
                               (function (k v)
                                 (environment:set! env k v)))
                  env)
                (environment env)
                bindings))))

# (list:map pair:head '((1 . a) (2 . b))) => (1 2)
(define list:map
  (function (f list)
    (if (pair? list)
        (pair (f (pair:head list))
              (list:map f (pair:tail list)))
        ())))

# (list:first list)
# (list:first '(a b c)) => a
# Get first element of a list.
(define list:first pair:head)

# (list:second list)
# (list:second '(a b c)) => b
# Get second element of a list.
(define list:second
  (function ((nil value . nil)) value))

# Like let, but binds symbol "name" in its body
# to a function, that takes as many arguments as there are
# bindings, and when called, binds all positional arguments
# and reruns the body. Inspired by scheme's named let form.
(define named-let
  (special (name bindings . body) env
    (let ((ptree (list:map list:first bindings))
          (values (list:map list:second bindings))
          (inner (environment env)))
      (evaluate (pair name values)
                (environment:set! inner
                                  name
                                  (evaluate (list:prepend function
                                                          ptree
                                                          body)
                                            inner))))))

# (loop ((a 5)) a) <=> (named-let recurse ((a 5)) a)
# Inspired by clojure's loop/recur.
(define loop
  (special (bindings . body) env
    (evaluate (list:prepend named-let 'recurse bindings body)
              env)))

# (+ 1 2 3) => 6
(define +
  (function numbers
    (list:fold (function (a e) (- e (- 0 a))) 0 numbers)))

(define list:length
  (function (list)
    (list:fold (function (n nil) (+ n 1)) 0 list)))

(define array
  (function objects
    (pair:tail
     (list:fold (function ((n . array) e)
                  (pair (+ n 1) (array:set! array n e)))
                (pair 0 (array::new (list:length objects) nil))
                objects))))

# (list:enumerate '(a b c)) => ((0 . a) (1 . b) (2 . c))
(define list:enumerate
  (function (list)
    (loop ((n 0)
           (l list))
      (if (pair? l)
          (pair (pair n (pair:head l))
                (recurse (+ n 1) (pair:tail l)))
          l))))

# Apply function to each element of the list and
# return the original list.
(define list:each
  (function (f list)
    (list:fold (function (nil e) (f e)) nil list)
    list))

# (when true 1 2) <=> (if true (do 1 2) nil)
(define when
  (special (test . body) env
    (if (evaluate test env)
        (evaluate-many body env)
        nil)))

# (when-not true 1 2) <=> (if true nil (do 1 2))
(define when-not
  (special (test . body) env
    (if (evaluate test env)
        nil
        (evaluate-many body env))))

(define define-record-type
  (special (name constructor-name predicate-name . slot-forms) env
    (let ((slot-names
            (list:map pair:head slot-forms))
          (type
            (apply array
                   (pair name slot-names)))
          (constructor
            (evaluate (list function
                            slot-names
                            (list:prepend record type slot-names))
                      env))
          (predicate
            (function (object)
              (and (record? object)
                   (== (record:type object) type))))
          (make-accessor
            (function (index)
              (evaluate (list function
                              (list name)
                              (list when
                                    (list predicate name)
                                    (list record:get name index)))
                        env)))
          (make-mutator
            (function (index)
              (evaluate (list function
                              (list name 'value)
                              (list when
                                    (list predicate name)
                                    (list record:set! name
                                          index
                                          'value)))
                        env))))
      (environment:set! env constructor-name constructor)
      (environment:set! env predicate-name predicate)
      (list:each (function ((index nil accessor mutator))
                   (environment:set! env
                                     accessor
                                     (make-accessor index))
                   (when-not (== mutator nil)
                     (environment:set! env
                                       mutator
                                       (make-mutator index))))
                 (list:enumerate slot-forms))
      nil)))

(define hash
  (function (object)
    (ifs ((string? object) (string:length object))
         ((symbol? object) (hash (symbol:name object)))
         (true             0))))

(define-record-type hashmap
  hashmap::new0
  hashmap?
  (hash-function hashmap:hash-function nil)
  (:data hashmap::data hashmap::data!))

# (define-record-type hashmap
#   (hashmap::new (hashmap:hash-function nil)
#                 (hashmap::data hashmap::data!))
#   (hashmap? object))

(define hashmap::new
  (function (capacity hash-function)
    (hashmap::new0 hash-function
                   (array::new capacity ()))))

(define hashmap:capacity
  (function (hashmap)
    (array:length (hashmap::data hashmap))))

(define alist:find
  (function (alist key)
    (if (pair? alist)
        (let (((entry . alist) alist))
          (if (== (pair:head entry) key)
              entry
              (alist:find alist key)))
        nil)))

(define hashmap:set!
  (function (hashmap key value)
    (let ((index (modulo ((hashmap:hash-function hashmap) key)
                         (hashmap:capacity hashmap)))
          (bucket (array:get (hashmap::data hashmap) index))
          (entry (alist:find bucket key)))
      (if (pair? entry)
          (pair:tail! entry value)
          (array:set! (hashmap::data hashmap)
                      index
                      (pair (pair key value) bucket)))
      hashmap)))

# (hashmap 'a 5 'b 6) => {a 5 b 6}
# {'a 5} <=> (hashmap 'a 5)
# Create a hashmap out of args, with each odd
# argument being the key, and each even - key's value.
(define hashmap
  (function objects
    (let ((length (list:length objects)))
      (if (odd? length)
          (die "hashmap: missing value")
          (loop ((h (hashmap::new length hash))
                 (os objects))
            (if (pair? os)
                (let (((key value . rest) os))
                  (recurse (hashmap:set! h key value) rest))
                h))))))

# (hashmap:get hashmap key)
# (hashmap:get hashmap key default)
(define hashmap:get
  (function (hashmap key . rest)
    (let ((index (modulo ((hashmap:hash-function hashmap) key)
                         (hashmap:capacity hashmap)))
          (bucket (array:get (hashmap::data hashmap) index))
          (entry (alist:find bucket key)))
      (if (pair? entry)
          (pair:tail entry)
          (if (pair? rest)
              (pair:head rest)
              nil)))))

######################################################################

# Evaluate forms in a sequence. If any of the arguments are
# falsey, return false, otherwise continue evaluating
# arguments and return last evaluated value.
(define and
  (special forms env
    (loop ((forms forms)
           (value true))
      (if value
          (if (pair? forms)
              (recurse (pair:tail forms)
                       (evaluate (pair:head forms) env))
              value)
          false))))

# Evaluate forms in a sequence, and if any of them are truthy,
# return it's value, or default to false.
(define or
  (special forms env
    (loop ((forms forms)
           (value false))
      (if value
          value
          (if (pair? forms)
              (recurse (pair:tail forms)
                       (evaluate (pair:head forms) env))
              false)))))

(define while
  (special (test . body) env
    (loop ((value nil))
      (if (evaluate test env)
          (recurse (evaluate-many body env))
          value))))

# (list:fold-right + 0 '(1 2 3)) <=> (+ 1 (+ 2 (+ 3 0)))
(define list:fold-right
  (function (f value list)
    (if (pair? list)
        (f (list:fold-right f value (pair:tail list))
	   (pair:head list))
	value)))

# (list:append '(1 2) () '(3)) => (1 2 3)
(define list:append
  (function lists
    (list:fold (function (l1 l2)
                 (list:fold-right (function (a e) (pair e a))
                                  l2
                                  l1))
               ()
               lists)))

(define list:copy
  (function (list)
    (list:fold-right (function (a e) (pair e a)) () list)))

# (list:reverse '(1 2 3)) => (3 2 1)
# Return a reversed copy of a list.
(define list:reverse
  (function (list)
    (list:fold (function (a e) (pair e a)) () list)))

# (list:filter odd? '(1 2 3 4 5)) => (1 3 5)
(define list:filter
  (function (f list)
    (list:fold-right (function (a e)
                       (if (f e) (pair e a) a))
                     ()
                     list)))

# (list:nth list n)
# (list:nth list n default)
(define list:nth
  (function (list n . rest)
    (loop ((list list)
           (n n)
           (default (if (pair? rest)
                        (pair:head rest)
                        nil)))
      (if (pair? list)
          (if (< n 1)
              (pair:head list)
              (recurse (pair:tail list) (- n 1) default))
          default))))

(define not
  (function (object)
    (== object false)))

# Execute body number of times.
# Bind is bound to the current iteration number, starting with 0.
(define dotimes
  (special ((bind count) . body) env
    (let ((count (evaluate count env))
          (env (environment env)))
      (ifs ((not (number? count))
            (die "dotimes: count is not a number."))
           ((not (symbol? bind))
            (die "dotimes: bind is not a symbol."))
           (true
            (loop ((n 0)
                   (value nil))
              (if (< n count)
                  (recurse (+ n 1)
                           (evaluate-many body
                                          (environment:set! env
                                                            bind
                                                            n)))
                  value)))))))

# (* 1 2 3 4) => 24
(define *
  (function numbers
    (define helper
      (function (y x)
        (if (== y 0)
            0
            (+ x (helper (- y 1) x)))))
    (if (pair? numbers)
        (list:fold helper 1 numbers)
        1)))

# (exponent 2 10) => 1024
# Return the exponential of base and power. 
(define exponent
  (function (base power)
    (define helper
      (function (b p)
        (if (< p 1)
            1
            (* b (helper b (- p 1))))))
    (if (< power 0)
        (/ 1 (helper base (- power)))
        (helper base power))))

# (modulus 5) => 5
# (modulus -5) => 5
# Return absolute value of number.
(define modulus
  (function (number)
    (if (< number 0)
        (- 0 number)
        number)))

(define >
  (function (number . numbers)
    (if (pair? numbers)
        (if (< (pair:head numbers) number)
            (apply > numbers)
            false)
        true)))

(define >=
  (function (number . numbers)
    (if (pair? numbers)
        (if (< number (pair:head numbers))
            false
            (apply >= numbers))
        true)))

(define <=
  (function (number . numbers)
    (if (pair? numbers)
        (if (> number (pair:head numbers))
            false
            (apply <= numbers))
        true)))

# Check if number is divisable by 2.
# Return nil if argument is not a number.
(define even?
  (function (number)
    (when (number? number)
      (== (modulo number 2) 0))))

# Check if number isn't divisable by 2.
# Return nil if argument is not a number.
(define odd?
  (function (number)
    (when (number? number)
      (== (modulo number 2) 1))))

(define array:copy
  (function (array)
    (let ((new-array (array::new (array:length array) nil)))
      (dotimes (n (array:length array))
        (array:set! new-array
                    n
                    (array:get array n))))))

# (environment:here)
# Return current environment.
(define environment:here
  (special () env env))

(define array:map!
  (function (f array)
    (dotimes (n (array:length array))
      (array:set! array n (f (array:get array n))))))
    
# (array:map function a)
(define array:map
  (function (f array)
    (array:map! f (array:copy array))))

# (array:fold + 0 [1 2 3]) <=> (+ (+ (+ 1 0) 2) 3)
(define array:fold
  (function (f value array)
    (let ((here (environment:here)))
      (dotimes (n (array:length array))
        (environment:set! here 'value (f value (array:get array n))))
      value)))

# Call function for each element of an array.
(define array:each
  (function (f array)
    (array:fold (function (nil e) (f e))
                nil
                array)
    array))

# Return a new string that is a concatenation of all argument strings.
(define string:append
  (function strings
    (let ((total-length
            (list:fold (function (a e)
                         (+ a (string:length e)))
                       0
                       strings))
          (result
            (string::new total-length)))
      (list:fold (function (offset element)
                   (let ((length (string:length element)))
                     (dotimes (n length)
                       (string:set! result
                                    (+ n offset)
                                    (string:get element n)))
                     (+ length offset)))
                 0
                 strings)
      result)))

######################################################################

(define hashmap?
  (function (object)
    (and (record? object)
         (== (record:type object) 'hashmap))))

(define hashmap:new
  (function (options)
    (hashmap::new (hashmap:get options 'capacity 10)
                  (hashmap:get options 'hash-function hash))))

# Check if key is present in hashmap.
(define hashmap:in?
  (function (hashmap key)
    (pair?
     (alist:find (array:get (hashmap::data hashmap)
                            (modulo ((hashmap:hash-function hashmap)
                                     key)
                                    (hashmap:capacity hashmap)))
                 key))))

(define hashmap:fold
  (function (f value hashmap)
    (array:fold (function (a bucket)
                  (list:fold f a bucket))
                value
                (hashmap::data hashmap))))

(define hashmap::copy-structure
  (function (hashmap)
    (hashmap::new (hashmap:capacity hashmap)
                  (hashmap:hash-function hashmap))))

(define hashmap:copy
  (function (hashmap)
    (hashmap:fold (function (a (k . v))
                    (hashmap:set! a k v))
                  (hashmap::copy-structure hashmap)
                  hashmap)))

# (hashmap:each function hashmap)
# Apply function to each of hashmap's key/value pairs and return the
# original hashmap.
(define hashmap:each
  (function (f hashmap)
    (hashmap:fold (function (nil kv) (f kv))
                  nil
                  hashmap)
    hashmap))

# Mutate the list by applying f to each of its elements.
(define list:map!
  (function (f list)
    (loop ((l list))
      (when (pair? l)
        (pair:head! l (f (pair:head l)))
        (recurse (pair:tail l))))
    list))

# Mutate the hashmap by applying f to each of its key/value pairs.
(define hashmap:map!
  (function (f hashmap)
    (array:map! (function (bucket)
                  (list:map! f bucket))
                (hashmap::data hashmap))
    hashmap))

# Create a new hashmap in which each key/value pair is the result of
# applying function to the key/value pair of hashmap.
(define hashmap:map
  (function (f hashmap)
    (hashmap:fold (function (a kv)
                    (let (((k . v) (f kv)))
                      (hashmap:set! a k v)))
                  (hashmap::copy-structure hashmap)
                  hashmap)))

(define hashmap:print
  (function (hashmap)
    (write "{")
    (hashmap:fold (function (a (k . v))
                    (when a
                      (write " "))
                    (print k)
                    (write " ")
                    (print v))
                  false
                  hashmap)
    (write "}")
    hashmap))

# TODO print implementation

######################################################################

# (identity x) => x
# Return argument as is.
(define identity (wrap quote))

# (list:third list)
# (list:third '(a b c)) => b
# Get third element of a list.
(define list:third
  (function ((nil nil value . nil)) value))

(define array:new
  (function (options)
    (array::new (hashmap:get options 'length 0)
                (hashmap:get options 'default nil))))

(define string:new
  (function (options)
    (string::new (hashmap:get options 'length 0)
                 (hashmap:get options 'default 0))))

# (maximum 3 6 9) => 9
(define maximum
  (function (number . numbers)
    (list:fold (function (last current)
                 (if (< last current)
                     current
                     last))
               number
               numbers)))

######################################################################

(define-record-type vector
  vector::new
  vector?
  (length vector:length vector:length!)
  (:data vector::data vector::data!))

(define vector:new
  (function (options)
    (let ((capacity (hashmap:get options 'capacity 0))
          (length (hashmap:get options 'length capacity)))
      (vector::new length (array::new capacity nil)))))

(define vector:capacity
  (function (vector)
    (array:length (vector::data vector))))

# (minimum 3 6 9) => 3
(define minimum
  (function (number . numbers)
    (list:fold (function (last current)
                 (if (> last current)
                     current
                     last))
               number
               numbers)))

(define vector:resize!
  (function (vector new-size)
    (if (== new-size (vector:capacity vector))
        vector
        (let ((data (vector::data vector))
              (new-data (array::new new-size nil)))
          (dotimes (n (minimum (array:length data) new-size))
            (array:set! new-data n (array:get data n)))
          (vector::data! vector new-data)
          vector))))

(define vector:shrink!
  (function (vector)
    (vector:resize! vector (vector:length vector))))

(define vector:set!
  (function (vector index value)
    (array:set! (vector::data vector) index value)
    vector))

# (vector:get vector index)
# (vector:get vector index default)
(define vector:get
  (function (vector index . rest)
    (array:get (vector::data vector) index (if (pair? rest)
                                               (pair:head rest)
                                               nil))))

(define vector:push!
  (function (vector object)
    (let ((length (vector:length vector))
          (capacity (vector:capacity vector)))
    (when (<= capacity length)
      (vector:resize! vector (* length 2)))
    (vector:length! vector (+ length 1))
    (vector:set! vector length object))))

(define vector:pop!
  (function (vector)
    (let ((length (- (vector:length vector) 1)))
      (vector:length! vector length)
      (vector:get vector length))))

(define vector
  (function objects
    (list:fold vector:push!
               (vector:new {'capacity (list:length objects)
                            'length 0})
               objects)))

(define vector:fold
  (function (f value vector)
    (let ((here (environment:here))
          (data (vector::data vector)))
      (dotimes (n (vector:length vector))
        (environment:set! here
                          'value
                          (f value (array:get data n))))
      value)))

(define vector:each
  (function (f vector)
    (vector:fold (function (nil e) (f e)) nil vector)
    vector))

(define vector:print
  (function (vector)
    (write "[")
    (vector:fold (function (first? e)
                   (when-not first? (write " "))
                   (print e)
                   false)
                 true
                 vector)
    (write "]")
    vector))

(define vector:map
  (function (f vector)
    (vector:fold (function (v e)
                   (vector:push! v (f e)))
                 (vector:new {'capacity (vector:length vector)
                              'length 0})
                 vector)))

(define vector:map!
  (function (f vector)
    (dotimes (n (vector:length vector))
      (vector:set! vector n (f (vector:get vector n))))
    vector))

(define vector:copy
  (function (vector)
    (vector:map identity vector)))

(define special:new
  (wrap (special (options) env
          (evaluate (list special
                          (hashmap:get options 'ptree nil)
                          (hashmap:get options 'ebind nil)
                          (hashmap:get options 'body nil))
                    (hashmap:get options 'env env)))))

(define function:new
  (function (options)
    (wrap (special:new options))))

# TODO numbers
(define symbol:generate
  (function ()
    (symbol "#symbol")))

(define list->array
  (function (list)
    (apply array list)))

(define array:fold-right
  (function (f value array)
    (let ((here (environment:here))
          (length (array:length array)))
      (dotimes (n length)
        (environment:set! here
                          'value
                          (f value
                             (array:get array (- length n 1)))))
      value)))

(define comment
  (special nil nil nil))
