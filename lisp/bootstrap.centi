# -*- mode: lisp -*-
# Bootstrap sequence for centi.
# All of required builtins are marked as such in builtins.lisp.

# (:define symbol value)
# A simplified version of define used for bootstrapping.
(environment:set! ((special () env env))
                  ((special (x) nil x) :define)
                  (special (symbol value) env
                    (environment:set! env
                                      symbol
                                      (evaluate value env))))

# NOTE defined here because it's part of the repl and
#      not doing so will break it.
(:define print :print)

(:define quote
  (special (form) nil form))

# Default truth value.
(:define true 'true)

# The only false value.
(:define false 'false)

# Lack of value.
(:define nil 'nil)

# Empty list symbol.
(:define () '())

(:define pair:head
  (wrap (special ((head . nil)) nil head)))

# (apply pair '(1 2)) <=> (pair '1 '2)
(:define apply
  (wrap (special (f args) nil
          (evaluate (pair (unwrap f) args)
                    (environment)))))

# (list:prepend 'x) <=> 'x
# (list:prepend 'x 'y) <=> (pair 'x 'y)
# (list:prepend 'x 'y 'z) <=> (pair 'x (pair 'y 'z))
# Create a new list with elements before last prepended
# to the last one.
(:define list:prepend
  (wrap (special (object . objects) env
          (if (pair? objects)
              (pair object (apply list:prepend objects))
              object))))

# (list . args)
# (list 'a (+ 1 2)) => (a 3)
(:define list
  (wrap (special args nil args)))

# (function (x) x) <=> (wrap (special (x) nil x))
(:define function
  (special (ptree . body) env
    (evaluate (list wrap
                    (list:prepend special ptree nil body))
              env)))

# (pair:tail pair)
# (pair:tail '(a . b)) => b
(:define pair:tail
  (function ((nil . tail)) tail))

# (list:fold + 0 '(1 2 3)) <=> (+ (+ (+ 1 0) 2) 3)
(:define list:fold
  (function (f value list)
    (if (pair? list)
        (list:fold f
                   (f value (pair:head list))
                   (pair:tail list))
        value)))

# Evaluate list of forms in provided environment,
# returning last result.
(:define evaluate-many
  (function (forms environment)
    (list:fold (function (nil f) (evaluate f environment))
               nil
               forms)))

# (ifs (x 1 2) (true 0)) <=> (if x (do 1 2) (if true (do 0) nil))
# If form with multiple tests.
(:define ifs
  (special ((test . body) . clauses) env
    (if (evaluate test env)
        (evaluate-many body env)
        (if (pair? clauses)
            (evaluate (pair ifs clauses) env)
            nil))))

(:define do
  (special forms env
    (evaluate-many forms env)))

# TODO die is not defined
# Destructure FORM over PTREE. Whenever ptree is a symbol, do
# (callback symbol form).
(:define destructure
  (function (ptree value callback)
    (ifs ((symbol? ptree)
          (ifs ((== ptree nil)
                nil)
               ((== ptree ())
                (if (== value ())
                    nil
                    (die "destructure: too many arguments")))
               (true
                (callback ptree value)
                nil)))
         ((pair? ptree)
          (if (pair? value)
              (do (destructure (pair:head ptree)
                               (pair:head value)
                               callback)
                  (destructure (pair:tail ptree)
                               (pair:tail value)
                               callback))
              (die "destructure: value is not a pair")))
         (true
          (die "destructure: bad ptree")))))

# Destructure value over the ptree and set each of
# the symbols to corresponding values in current environment.
(:define define
  (special (ptree value) env
    (:define value (evaluate value env))
    (destructure ptree value (function (k v)
                               (environment:set! env k v)))
    value))

# (let ((a 1) (b (+ a 2))) b) <=>
#   ((function (a) ((function (b) b) (+ a 2))) 1)
(define let
  (special (bindings . body) env
    (evaluate-many
     body
     (list:fold (function (env (ptree form))
                  (destructure ptree
                               (evaluate form env)
                               (function (k v)
                                 (environment:set! env k v)))
                  env)
                (environment env)
                bindings))))

# (list:map pair:head '((1 . a) (2 . b))) => (1 2)
(define list:map
  (function (f list)
    (if (pair? list)
        (pair (f (pair:head list))
              (list:map f (pair:tail list)))
        ())))

# (list:first list)
# (list:first '(a b c)) => a
# Get first element of a list.
(define list:first pair:head)

# (list:second list)
# (list:second '(a b c)) => b
# Get second element of a list.
(define list:second
  (function ((nil value . nil)) value))

# Like let, but binds symbol "name" in its body
# to a function, that takes as many arguments as there are
# bindings, and when called, binds all positional arguments
# and reruns the body. Inspired by scheme's named let form.
(define named-let
  (special (name bindings . body) env
    (let ((ptree (list:map list:first bindings))
          (values (list:map list:second bindings))
          (inner (environment env)))
      (evaluate (pair name values)
                (environment:set! inner
                                  name
                                  (evaluate (list:prepend function
                                                          ptree
                                                          body)
                                            inner))))))

# (loop ((a 5)) a) <=> (named-let recurse ((a 5)) a)
# Inspired by clojure's loop/recur.
(define loop
  (special (bindings . body) env
    (evaluate (list:prepend named-let 'recurse bindings body)
              env)))

######################################################################

# Evaluate forms in a sequence. If any of the arguments are
# falsey, return false, otherwise continue evaluating
# arguments and return last evaluated value.
(define and
  (special forms env
    (loop ((forms forms)
           (value true))
      (if value
          (if (pair? forms)
              (recurse (pair:tail forms)
                       (evaluate (pair:head forms) env))
              value)
          false))))

# Evaluate forms in a sequence, and if any of them are truthy,
# return it's value, or default to false.
(define or
  (special forms env
    (loop ((forms forms)
           (value false))
      (if value
          value
          (if (pair? forms)
              (recurse (pair:tail forms)
                       (evaluate (pair:head forms) env))
              false)))))

(define list:length
  (function (list)
    (list:fold (function (n nil) (+ n 1)) 0 list)))

# (when true 1 2) <=> (if true (do 1 2) nil)
(define when
  (special (test . body) env
    (if (evaluate test env)
        (evaluate-many body env)
        nil)))

# (when-not true 1 2) <=> (if true nil (do 1 2))
(define when-not
  (special (test . body) env
    (if (evaluate test env)
        nil
        (evaluate-many body env))))

(define while
  (special (test . body) env
    (loop ((value nil))
      (if (evaluate test env)
          (recurse (evaluate-many body env))
          value))))

# (list:fold-right + 0 '(1 2 3)) <=> (+ 1 (+ 2 (+ 3 0)))
(define list:fold-right
  (function (f value list)
    (if (pair? list)
        (f (list:fold-right f value (pair:tail list))
	   (pair:head list))
	value)))

# (list:append '(1 2) () '(3)) => (1 2 3)
(define list:append
  (function lists
    (list:fold (function (l1 l2)
                 (list:fold-right (function (a e) (pair e a))
                                  l2
                                  l1))
               ()
               lists)))

(define list:copy
  (function (list)
    (list:fold-right (function (a e) (pair e a)) () list)))

# (list:reverse '(1 2 3)) => (3 2 1)
# Return a reversed copy of a list.
(define list:reverse
  (function (list)
    (list:fold (function (a e) (pair e a)) () list)))

# Apply function to each element of the list and
# return the original list.
(define list:each
  (function (f list)
    (list:fold (function (nil e) (f e)) nil list)
    list))

# (list:filter odd? '(1 2 3 4 5)) => (1 3 5)
(define list:filter
  (function (f list)
    (list:fold-right (function (a e)
                       (if (f e) (pair e a) a))
                     ()
                     list)))

# (list:nth list n)
# (list:nth list n default)
(define list:nth
  (function (list n . rest)
    (loop ((list list)
           (n n)
           (default (if (pair? rest)
                        (pair:head rest)
                        nil)))
      (if (pair? list)
          (if (< n 1)
              (pair:head list)
              (recurse (pair:tail list) (- n 1) default))
          default))))

(define not
  (function (object)
    (== object false)))

# Execute body number of times.
# Bind is bound to the current iteration number, starting with 0.
(define dotimes
  (special ((bind count) . body) env
    (let ((count (evaluate count env))
          (env (environment env)))
      (ifs ((not (number? count))
            (die "dotimes: count is not a number."))
           ((not (symbol? bind))
            (die "dotimes: bind is not a symbol."))
           (true
            (loop ((n 0)
                   (value nil))
              (if (< n count)
                  (recurse (+ n 1)
                           (evaluate-many body
                                          (environment:set! env
                                                            bind
                                                            n)))
                  value)))))))

# (+ 1 2 3) => 6
(define +
  (function numbers
    (list:fold (function (a e) (- e (- 0 a))) 0 numbers)))

# (* 1 2 3 4) => 24
(define *
  (function numbers
    (define helper
      (function (y x)
        (if (== y 0)
            0
            (+ x (helper (- y 1) x)))))
    (if (pair? numbers)
        (list:fold helper 1 numbers)
        1)))

# (exponent 2 10) => 1024
# Return the exponential of base and power. 
(define exponent
  (function (base power)
    (define helper
      (function (b p)
        (if (< p 1)
            1
            (* b (helper b (- p 1))))))
    (if (< power 0)
        (/ 1 (helper base (- power)))
        (helper base power))))

# (modulus 5) => 5
# (modulus -5) => 5
# Return absolute value of number.
(define modulus
  (function (number)
    (if (< number 0)
        (- 0 number)
        number)))

(define >
  (function (number . numbers)
    (if (pair? numbers)
        (if (< (pair:head numbers) number)
            (apply > numbers)
            false)
        true)))

(define >=
  (function (number . numbers)
    (if (pair? numbers)
        (if (< number (pair:head numbers))
            false
            (apply >= numbers))
        true)))

(define <=
  (function (number . numbers)
    (if (pair? numbers)
        (if (> number (pair:head numbers))
            false
            (apply <= numbers))
        true)))

# Check if number is divisable by 2.
# Return nil if argument is not a number.
(define even?
  (function (number)
    (when (number? number)
      (== (modulo number 2) 0))))

# Check if number isn't divisable by 2.
# Return nil if argument is not a number.
(define odd?
  (function (number)
    (when (number? number)
      (== (modulo number 2) 1))))

(define array
  (function objects
    (pair:tail
     (list:fold (function ((n . array) e)
                  (pair (+ n 1) (array:set! array n e)))
                (pair 0 (array::new (list:length objects) nil))
                objects))))

(define array:copy
  (function (array)
    (let ((new-array (array::new (array:length array) nil)))
      (dotimes (n (array:length array))
        (array:set! new-array
                    n
                    (array:get array n))))))

# (environment:here)
# Return current environment.
(define environment:here
  (special () env env))

(define array:map!
  (function (f array)
    (dotimes (n (array:length array))
      (array:set! array n (f (array:get array n))))))
    
# (array:map function a)
(define array:map
  (function (f array)
    (array:map! f (array:copy array))))

# (array:fold + 0 [1 2 3]) <=> (+ (+ (+ 1 0) 2) 3)
(define array:fold
  (function (f value array)
    (let ((here (environment:here)))
      (dotimes (n (array:length array))
        (environment:set! here
                          'value
                          (f value (array:get array n))))
      value)))

# Call function for each element of an array.
(define array:each
  (function (f array)
    (array:fold (function (nil e) (f e))
                nil
                array)
    array))

# Return a new string that is a concatenation of all argument strings.
(define string:append
  (function strings
   (list:fold (function (s1 s2)
                (let ((l1 (string:length s1))
                      (l2 (string:length s2))
                      (new-string (string::new (+ l1 l2))))
                  (dotimes (n l1)
                    (string:set! new-string n (string:get s1 n)))
                  (dotimes (n l2)
                    (string:set! new-string
                                 (+ n l1)
                                 (string:get s2 n)))
                  new-string))
              ""
              strings)))

######################################################################

(define alist:find
  (function (alist key)
    (if (pair? alist)
        (let (((entry . alist) alist))
          (if (== (pair:head entry) key)
              entry
              (alist:find alist key)))
        nil)))

(define hash
  (function (object)
    (ifs ((string? object) (string:length object))
         ((symbol? object) (hash (symbol:name object)))
         (true             0))))

(define hashmap::new
  (function (capacity hash-function)
    (record 'hashmap
            (array::new capacity ())
            hash-function)))

(define hashmap?
  (function (object)
    (and (record? object)
         (== (record:type object) 'hashmap))))

(define hashmap::data
  (function (hashmap)
    (record:get hashmap 0)))

(define hashmap::data!
  (function (hashmap value)
    (record:set! hashmap 0 value)))

(define hashmap:hash-function
  (function (hashmap)
    (record:get hashmap 1)))

(define hashmap:capacity
  (function (hashmap)
    (array:length (hashmap::data hashmap))))

(define hashmap:set!
  (function (hashmap key value)
    (let ((index (modulo ((hashmap:hash-function hashmap) key)
                         (hashmap:capacity hashmap)))
          (bucket (array:get (hashmap::data hashmap) index))
          (entry (alist:find bucket key)))
      (if (pair? entry)
          (pair:tail! entry value)
          (array:set! (hashmap::data hashmap)
                      index
                      (pair (pair key value) bucket)))
      hashmap)))

# (hashmap:get hashmap key)
# (hashmap:get hashmap key default)
(define hashmap:get
  (function (hashmap key . rest)
    (let ((index (modulo ((hashmap:hash-function hashmap) key)
                         (hashmap:capacity hashmap)))
          (bucket (array:get (hashmap::data hashmap) index))
          (entry (alist:find bucket key)))
      (if (pair? entry)
          (pair:tail entry)
          (if (pair? rest)
              (pair:head rest)
              nil)))))

# (hashmap 'a 5 'b 6) => {a 5 b 6}
# {'a 5} <=> (hashmap 'a 5)
# Create a hashmap out of args, with each odd
# argument being the key, and each even - key's value.
(define hashmap
  (function objects
    (let ((length (list:length objects)))
      (if (odd? length)
          (die "hashmap: missing value")
          (loop ((h (hashmap::new length hash))
                 (os objects))
            (if (pair? os)
                (let (((key value . rest) os))
                  (recurse (hashmap:set! h key value) rest))
                h))))))

(define hashmap:new
  (function (options)
    (hashmap::new (hashmap:get options 'capacity 10)
                  (hashmap:get options 'hash-function hash))))

# Check if key is present in hashmap.
(define hashmap:in?
  (function (hashmap key)
    (pair?
     (alist:find (array:get (hashmap::data hashmap)
                            (modulo ((hashmap:hash-function hashmap)
                                     key)
                                    (hashmap:capacity hashmap)))
                 key))))

(define hashmap:fold
  (function (f value hashmap)
    (array:fold (function (a bucket)
                  (list:fold f a bucket))
                value
                (hashmap::data hashmap))))

(define hashmap::copy-structure
  (function (hashmap)
    (hashmap::new (hashmap:capacity hashmap)
                  (hashmap:hash-function hashmap))))

(define hashmap:copy
  (function (hashmap)
    (hashmap:fold (function (a (k . v))
                    (hashmap:set! a k v))
                  (hashmap::copy-structure hashmap)
                  hashmap)))

# (hashmap:each function hashmap)
# Apply function to each of hashmap's key/value pairs and return the
# original hashmap.
(define hashmap:each
  (function (f hashmap)
    (hashmap:fold (function (nil kv) (f kv))
                  nil
                  hashmap)
    hashmap))

# Mutate the list by applying f to each of its elements.
(define list:map!
  (function (f list)
    (loop ((l list))
      (when (pair? l)
        (pair:head! l (f (pair:head l)))
        (recurse (pair:tail l))))
    list))

# Mutate the hashmap by applying f to each of its key/value pairs.
# TODO test
(define hashmap:map!
  (function (f h)))

# Create a new hashmap in which each key/value pair is the result of
# applying function to the key/value pair of hashmap.
(define hashmap:map
  (function (f hashmap)
    (hashmap:fold (function (a kv)
                    (let (((k . v) (f kv)))
                      (hashmap:set! a k v)))
                  (hashmap::copy-structure hashmap)
                  hashmap)))

(define hashmap:print
  (function (hashmap)
    (write "{")
    (hashmap:fold (function (a (k . v))
                    (when a
                      (write " "))
                    (print k)
                    (write " ")
                    (print v))
                  false
                  hashmap)
    (write "}")
    hashmap))

# TODO print implementation

######################################################################

# (identity x) => x
# Return argument as is.
(define identity (wrap quote))

# (list:third list)
# (list:third '(a b c)) => b
# Get third element of a list.
(define list:third
  (function ((nil nil value . nil)) value))

(define array:new
  (function (options)
    (array::new (hashmap:get options 'length 0)
                (hashmap:get options 'default nil))))

(define string:new
  (function (options)
    (string::new (hashmap:get options 'length 0)
                 (hashmap:get options 'default 0))))

# (minimum 3 6 9) => 3
(define minimum
  (function (number . numbers)
    (list:fold (function (last current)
                 (if (> last current)
                     current
                     last))
               number
               numbers)))

# (maximum 3 6 9) => 9
(define maximum
  (function (number . numbers)
    (list:fold (function (last current)
                 (if (< last current)
                     current
                     last))
               number
               numbers)))
