# -*- mode: lisp -*-

# (loop bindings . body)
# Same as (named-let recurse bindings . body).
# Inspired by clojure's loop/recur.
(define loop
  (special (bindings . body) env
    (evaluate (list:prepend named-let 'recurse bindings body)
              env)))

### Hashmaps #########################################################

# (each function hashmap)
(define h:each
  (function (f h)
    (list:each f (r:get h 1))))

# (map! function hashmap)
(define h:map!
  (function (f h)
    (list:map! f (r:get h 1))
    h))

# (map function hashmap)
(define h:map
  (function (f h)
    (record 'hashmap (list:map f (r:get h 1)))))

### Pattern matching #################################################

# (defun identity (x) x) <=> (define identity (function (x) x)).
(define defun
  (special (name . body) env
    (let ((value (evaluate (pair function body) env)))
      (environment:set! env name value)
      value)))

(defun match::matches? (ptree form)
  (if* ((== ptree ())   (== form ()))
       ((symbol? ptree) true)
       ((pair? ptree)   (if (pair? form)
                            (if (match::matches? (list:head ptree)
                                                 (list:head form))
                                (match::matches? (list:tail ptree)
                                                 (list:tail form))
                                false)
                             false))
       (true            false)))

(define match
  (special (form . clauses) env
    (defun helper (((pattern . body) . clauses) value)
      (if (match::matches? pattern value)
          (evaluate (list:prepend let
                           (list:list (list:list pattern
                                           (list:list quote value)))
                           body)
                env)
          (if (pair? clauses)
              (helper clauses value)
              nil)))
    (helper clauses (evaluate form env))))

(define match-fn
  (special clauses env
    (define body
      (list:prepend match 'args
                 (list:append clauses
                           '((_ (die "match-fn: invalid arity"))))))
    (evaluate (list:list function 'args body) env)))

### Rest #############################################################

# (= object . objects)
# Check objects' structural equality.
(defun = (o . os)
  (defun equal? (o1 o2)
    (if* ((== o1 o2) true)
         ((pair? o1)
          (if (pair? o2)
              (if (equal? (list:head o1) (list:head o2))
                  (equal? (list:tail o1) (list:tail o2))
                  false)
              false))
         (true false))) # TODO call generic = function
  (list:fold equal? o os))

# (compose . functions)
# (compose print -) <=> (function (x) (print (- x)))
# TODO import list lib
(define compose
  (function fs
    (function (x)
      (list:fold-right (function (acc elt) (elt acc))
                       x
                       fs))))
